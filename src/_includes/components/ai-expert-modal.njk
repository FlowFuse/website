<!-- AI Expert Assistant Modal -->
<div id="ai-expert-modal" class="fixed inset-0 bg-black/50 hidden items-center justify-center p-0 md:p-4 md:px-8 md:py-8 z-[9999]">
    <!-- Modal Content -->
    <div class="bg-white rounded-none md:rounded-lg shadow-xl w-full max-w-4xl h-full md:h-full flex flex-col relative">
        
        <!-- Header -->
        <div class="ai-chat-box"><div class="textarea-wrapper modal-header flex items-center justify-between px-4 py-3 rounded-t-none md:rounded-t-lg h-auto rounded-b-none mb-0">
            <div class="flex items-center gap-1">
                <!-- FlowFuse Logo -->
                <div class="w-24 h-6">
                    {% include "components/flowfuse-wordmark.njk" %}
                </div>
                <h2 class="text-base font-semibold text-gray-700" style="margin-bottom: -3px;">Expert Assistant</h2>
            </div>
            <button id="close-modal" class="text-gray-400 hover:text-gray-600">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                    <path d="M18 6L6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
        </div></div>

        <!-- Chat Content -->
        <div class="flex-1 p-4 overflow-y-auto">
            <!-- Info Message -->
            <div class="bg-indigo-100 rounded-lg mb-6 py-3 px-4">
                <p class="text-indigo-700 text-sm m-0">
                    Uses OpenAI GPT-4.1 Mini with access to all FlowFuse 
                    <a href="/docs" class="underline">documentation</a> 
                    and our Get Started 
                    <a href="https://www.youtube.com/watch?v=K4xw09DbSdI&list=PLpcyqc7kNgp1dCDliNM4WOPf6d42Qmjvf" class="underline">YouTube playlist</a>
                </p>
            </div>

            <!-- Chat Messages Container -->
            <div id="chat-messages" class="space-y-4">
                <!-- Messages will be added here dynamically -->
            </div>

        </div>

        <!-- Input Area -->
        <div class="p-4 bg-white rounded-b-none md:rounded-b-lg border-t border-gray-200">
            <div id="action-buttons-container" class="pb-4 flex justify-between">
                <button id="clear-conversation" class="bg-white border border-indigo-300 rounded-full text-sm py-2 px-3 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    Clear
                </button>
                <div id="right-buttons" class="flex gap-2">
                    <button id="stop-generation" class="bg-white border border-indigo-300 rounded-full text-sm flex items-center gap-2 py-2 px-3 hidden">
                        <div class="w-3 h-3 bg-gray-800 rounded-sm"></div>
                        Stop
                    </button>
                    <button id="summarize-conversation" class="bg-white border border-indigo-300 rounded-full text-sm py-2 px-3 hidden">
                        Summarize this conversation
                    </button>
                </div>
            </div>
            <div class="relative">
                <textarea 
                    id="modal-input"
                    placeholder="Give more details in regards to your intended workflow to tailor it to your use case"
                    class="w-full p-4 border-2 border-gray-300 rounded-lg resize-none focus:outline-none focus:border-indigo-500 text-gray-900 h-24 text-sm disabled:cursor-not-allowed disabled:bg-gray-50 disabled:text-gray-500"
                ></textarea>
            </div>
            <div class="flex justify-between mt-2 text-xs text-gray-500">
                <span>Powered by OpenAI</span>
                <span>Rate limited. Fair use only</span>
            </div>
        </div>

    </div>
</div>

<!-- JavaScript for Modal Functionality -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    const modal = document.getElementById('ai-expert-modal');
    const closeBtn = document.getElementById('close-modal');
    const tellMeHowBtn = document.querySelector('[onclick*="cta-ai-tell-me-how"]');
    const chatMessages = document.getElementById('chat-messages');
    const modalInput = document.getElementById('modal-input');
    
    // Message storage array
    let messages = [];
    
    // Session ID for chat isolation
    let sessionId = null;
    
    // Variables for stopping generation
    let currentAbortController = null;
    let isGenerating = false;
    
    // Auto-scroll management
    let autoScrollEnabled = true;
    const scrollThreshold = 50; // pixels from bottom to consider "at bottom"

    // Centralized function to manage input state based on isGenerating
    function updateInputState() {
        const clearBtn = document.getElementById('clear-conversation');
        const stopBtn = document.getElementById('stop-generation');
        const summarizeBtn = document.getElementById('summarize-conversation');
        
        if (isGenerating) {
            modalInput.disabled = true;
            // Disable clear button during generation
            if (clearBtn) clearBtn.disabled = true;
            // Show stop button, hide summarize button
            if (stopBtn) stopBtn.classList.remove('hidden');
            if (summarizeBtn) summarizeBtn.classList.add('hidden');
        } else {
            modalInput.disabled = false;
            modalInput.focus();
            // Enable clear button only if there are messages
            const hasMessages = messages.length > 0;
            if (clearBtn) clearBtn.disabled = !hasMessages;
            // Hide stop button, show summarize button if there are messages
            if (stopBtn) stopBtn.classList.add('hidden');
            if (summarizeBtn) {
                if (hasMessages) {
                    summarizeBtn.classList.remove('hidden');
                } else {
                    summarizeBtn.classList.add('hidden');
                }
            }
        }
    }

    // Check if user is at bottom of scroll container
    function isAtBottom() {
        const container = chatMessages.parentElement; // Get the scrollable container
        return container.scrollHeight - container.scrollTop - container.clientHeight < scrollThreshold;
    }
    
    // Scroll to bottom if auto-scroll is enabled
    function scrollToBottom() {
        if (autoScrollEnabled) {
            const container = chatMessages.parentElement;
            container.scrollTop = container.scrollHeight;
        }
    }
    
    // Set up scroll detection on the chat container
    const chatContainer = chatMessages.parentElement;
    chatContainer.addEventListener('scroll', function() {
        // Check if user is at bottom
        if (isAtBottom()) {
            // Re-enable auto-scroll when user scrolls to bottom
            autoScrollEnabled = true;
        } else {
            // Disable auto-scroll when user scrolls up
            autoScrollEnabled = false;
        }
    });
    
    // Open modal
    if (tellMeHowBtn) {
        tellMeHowBtn.addEventListener('click', function(e) {
            e.preventDefault();
            const userText = document.querySelector('textarea[aria-label="Describe your workflow"]').value;
            const promptText = userText.trim();
            openModal(promptText);
        });
    }

    // Close modal
    closeBtn.addEventListener('click', closeModal);
    modal.addEventListener('click', function(e) {
        if (e.target === modal) closeModal();
    });

    // Handle prompt pill clicks
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('prompt-pill') && e.target.dataset.prompt) {
            e.preventDefault();
            const promptText = e.target.dataset.prompt;
            openModal(promptText);
        }
    });

    function openModal(userText) {
        // Generate new session ID for this chat session
        sessionId = crypto.randomUUID();
        
        // Reset auto-scroll to enabled when opening modal
        autoScrollEnabled = true;
        
        // Ensure input is enabled when modal opens
        isGenerating = false;
        
        // Only show welcome message if there are no messages yet AND no user text provided
        if (messages.length === 0 && !userText) {
            showWelcomeMessage();
        }
        updateInputState();
        
        // Check if View Transitions API is supported
        if (document.startViewTransition && typeof document.startViewTransition === 'function') {
            
            // Get elements for transition
            const homeTextarea = document.querySelector('textarea[aria-label="Describe your workflow"]');
            const homeTextareaWrapper = homeTextarea.closest('.textarea-wrapper');
            // Target the entire input area div that contains textarea and footer text
            const modalInputSection = modal.querySelector('.p-4.bg-white.rounded-b-none.md\\:rounded-b-lg');
            
            
            // Set transition name on home wrapper BEFORE starting transition (for "before" snapshot)
            homeTextareaWrapper.style.viewTransitionName = 'morphing-content';
            
            // Use View Transitions API for smooth morphing
            try {
                const transition = document.startViewTransition(() => {
                    
                    // Remove transition name from home wrapper
                    homeTextareaWrapper.style.viewTransitionName = '';
                    
                    // Hide the home wrapper
                    homeTextareaWrapper.style.display = 'none';
                    
                    // Move modal to document.body and show it
                    document.body.appendChild(modal);
                    modal.classList.remove('hidden');
                    modal.classList.add('flex');
                    
                    // Give the modal input section the transition name (for "after" snapshot)
                    if (modalInputSection) {
                        modalInputSection.style.viewTransitionName = 'morphing-content';
                    }
                    
                });
                
            
            transition.finished.then(() => {
                
                // Prevent body scroll
                document.body.style.overflow = 'hidden';
                
                // Clean up transition names after animation
                if (homeTextareaWrapper) {
                    homeTextareaWrapper.style.viewTransitionName = '';
                }
                if (modalInputSection) {
                    modalInputSection.style.viewTransitionName = '';
                }
                
                // Start chat if user provided text
                if (userText) {
                    startChat(userText);
                }
            }).catch(err => {
                console.error('Transition failed:', err);
            });
            } catch (error) {
                console.error('Error starting transition:', error);
                // Fallback to immediate modal show
                homeTextareaWrapper.style.display = 'none';
                document.body.appendChild(modal);
                modal.classList.remove('hidden');
                modal.classList.add('flex');
                document.body.style.overflow = 'hidden';
                if (userText) {
                    modalInput.value = userText;
                    startChat(userText);
                }
            }
        } else {
            // Fallback for browsers without View Transitions support
            const homeTextarea = document.querySelector('textarea[aria-label="Describe your workflow"]');
            const homeTextareaWrapper = homeTextarea.closest('.textarea-wrapper');
            
            
            // Hide home textarea to avoid duplication
            homeTextareaWrapper.style.display = 'none';
            
            // Show modal immediately (no animation)
            document.body.appendChild(modal);
            modal.classList.remove('hidden');
            modal.classList.add('flex');
            document.body.style.overflow = 'hidden';
            
            if (userText) {
                startChat(userText);
            }
        }
    }

    function closeModal() {
        const homeTextarea = document.querySelector('textarea[aria-label="Describe your workflow"]');
        const homeTextareaWrapper = homeTextarea ? homeTextarea.closest('.textarea-wrapper') : null;
        const modalInputSection = modal.querySelector('.p-4.bg-white.rounded-b-none.md\\:rounded-b-lg');
        
        // Check if View Transitions API is supported
        if (document.startViewTransition && typeof document.startViewTransition === 'function') {
            // Set transition name on modal input section (for "before" snapshot)
            if (modalInputSection) {
                modalInputSection.style.viewTransitionName = 'morphing-content';
            }
            
            // Use View Transitions for smooth reverse morph
            const transition = document.startViewTransition(() => {
                // Remove transition name from modal
                if (modalInputSection) {
                    modalInputSection.style.viewTransitionName = '';
                }
                
                // Hide modal
                modal.classList.add('hidden');
                modal.classList.remove('flex');
                
                // Show home wrapper with transition name (for "after" snapshot)
                if (homeTextareaWrapper) {
                    homeTextareaWrapper.style.display = '';
                    homeTextareaWrapper.style.viewTransitionName = 'morphing-content';
                }
            });
            
            transition.finished.then(() => {
                // Clean up after transition
                document.body.style.overflow = '';
                if (homeTextareaWrapper) {
                    homeTextareaWrapper.style.viewTransitionName = '';
                }
                
                // Reset modal state
                clearMessages();
                modalInput.value = '';
                sessionId = null;  // Clear session ID
                
                // Hide both button containers
                const stopButtonContainer = document.getElementById('stop-button-container');
                const summarizeButtonContainer = document.getElementById('summarize-button-container');
                stopButtonContainer.classList.add('hidden');
                summarizeButtonContainer.classList.add('hidden');
            });
        } else {
            // Fallback for browsers without View Transitions
            modal.classList.add('hidden');
            modal.classList.remove('flex');
            document.body.style.overflow = '';
            
            // Restore home textarea
            if (homeTextareaWrapper) {
                homeTextareaWrapper.style.display = '';
            }
            
            // Reset state
            clearMessages();
            modalInput.value = '';
            sessionId = null;  // Clear session ID
            
            // Hide both button containers
            const stopButtonContainer = document.getElementById('stop-button-container');
            const summarizeButtonContainer = document.getElementById('summarize-button-container');
            stopButtonContainer.classList.add('hidden');
            summarizeButtonContainer.classList.add('hidden');
        }
        
    }

    async function startChat(message) {        
        // Mark as generating and update UI
        isGenerating = true;
        updateInputState();
        
        // Add user message
        addMessage(message, 'human');
        
        // Start AI response
        const aiMessageIndex = addProgressiveMessage('', 'ai');
        
        try {
            // Make API call
            const response = await sendChatMessage(message);
            
            // Simulate progressive text display
            const words = response.split(' ');
            let currentText = '';
            
            for (let i = 0; i < words.length; i++) {
                // Check if generation was stopped
                if (!isGenerating) {
                    break;
                }
                
                currentText += (i > 0 ? ' ' : '') + words[i];
                updateMessage(aiMessageIndex, currentText);
                
                // Small delay between words for streaming effect
                await new Promise(resolve => setTimeout(resolve, 50));
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                // Update message to show it was stopped
                updateMessage(aiMessageIndex, messages[aiMessageIndex].content + ' [Generation stopped]');
            } else {
                // Handle other errors
                updateMessage(aiMessageIndex, 'Sorry, an error occurred while generating the response.');
            }
        }
        
        // Mark generation as complete
        isGenerating = false;
        currentAbortController = null;
        updateInputState();
        
        // Button visibility is now handled by updateInputState()
    }

    function addMessage(content, type) {
        // Add to messages array
        const message = { content, type };
        messages.push(message);
        
        // Create DOM element
        const messageDiv = document.createElement('div');
        messageDiv.className = `flex ${type === 'human' ? 'justify-end' : 'justify-start'} mb-4`;
        
        const messageBubble = document.createElement('div');
        messageBubble.className = `max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${
            type === 'human' 
                ? 'bg-indigo-600 text-white rounded-br-sm' 
                : 'bg-gray-100 text-gray-800 rounded-bl-sm'
        }`;
        messageBubble.textContent = content;
        
        messageDiv.appendChild(messageBubble);
        chatMessages.appendChild(messageDiv);
        
        // Scroll to bottom using auto-scroll function
        scrollToBottom();
    }

    function renderMessages() {
        // Clear existing messages in DOM
        chatMessages.innerHTML = '';
        
        // Rebuild from messages array
        messages.forEach(message => {
            const messageDiv = document.createElement('div');
            messageDiv.className = `flex ${message.type === 'human' ? 'justify-end' : 'justify-start'} mb-4`;
            
            const messageBubble = document.createElement('div');
            messageBubble.className = `max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${
                message.type === 'human' 
                    ? 'bg-indigo-600 text-white rounded-br-sm' 
                    : 'bg-gray-100 text-gray-800 rounded-bl-sm'
            }`;
            messageBubble.textContent = message.content;
            
            messageDiv.appendChild(messageBubble);
            chatMessages.appendChild(messageDiv);
        });
        
        // Scroll to bottom using auto-scroll function
        scrollToBottom();
    }

    function clearMessages() {
        // Clear messages array
        messages = [];
        
        // Clear DOM
        chatMessages.innerHTML = '';
    }

    async function showWelcomeMessage() {
        // Add welcome message container (this doesn't count as a real conversation message)
        const messageDiv = document.createElement('div');
        messageDiv.className = 'flex justify-start mb-4';
        
        const messageBubble = document.createElement('div');
        messageBubble.className = 'max-w-xs lg:max-w-md px-4 py-2 rounded-lg bg-gray-100 text-gray-800 rounded-bl-sm';
        messageBubble.textContent = '';
        
        messageDiv.appendChild(messageBubble);
        chatMessages.appendChild(messageDiv);
        scrollToBottom();
        
        // Animate the typing of the welcome message
        const welcomeText = 'Hello! I am here to help you get started with FlowFuse and Node-RED. Please tell me what you are hoping to achieve.';
        const words = welcomeText.split(' ');
        let currentText = '';
        
        for (let i = 0; i < words.length; i++) {
            currentText += (i > 0 ? ' ' : '') + words[i];
            messageBubble.textContent = currentText;
            scrollToBottom();
            
            // Small delay between words for typing effect
            await new Promise(resolve => setTimeout(resolve, 50));
        }
    }

    async function clearConversation() {
        // Stop any ongoing generation
        if (currentAbortController) {
            currentAbortController.abort();
        }
        isGenerating = false;
        
        // Clear all messages
        clearMessages();
        
        // Reset session ID for fresh conversation
        sessionId = crypto.randomUUID();
        
        // Reset auto-scroll
        autoScrollEnabled = true;
        
        // Show welcome message with typing animation
        await showWelcomeMessage();
        
        // Hide right buttons
        const stopBtn = document.getElementById('stop-generation');
        const summarizeBtn = document.getElementById('summarize-conversation');
        if (stopBtn) stopBtn.classList.add('hidden');
        if (summarizeBtn) summarizeBtn.classList.add('hidden');
        
        // Update input state (clear button will be disabled since messages array is empty)
        updateInputState();
    }

    async function sendChatMessage(query) {
        try {
            // Create abort controller for this request
            currentAbortController = new AbortController();
            
            // Note: This API may only work in production (flowfuse.com domain)
            // For local development, we'll get simulated responses
            const response = await fetch('https://flowfuse-chatbot.flowfuse.dev/v1/expert', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Origin': window.location.origin,
                    'X-Chat-Session-ID': sessionId
                },
                body: JSON.stringify({ query }),
                signal: currentAbortController.signal
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            return data.answer;
        } catch (error) {
            // Handle abort error (user clicked stop)
            if (error.name === 'AbortError') {
                throw error; // Re-throw abort errors to be handled by caller
            }
            
            console.warn('Chat API not available (likely due to CORS in development):', error);
            
            // Fallback to simulated response for local development
            const simulatedResponses = {
                default: "I'm here to help you get started with FlowFuse and Node-RED. While the API is not available in development mode, I can still provide guidance on setting up your workflows, creating dashboards, and integrating with industrial systems.",
                summary: "We discussed FlowFuse implementation strategies and Node-RED workflow development."
            };
            
            // Check if this is a summary request
            if (query.includes('summary')) {
                return simulatedResponses.summary;
            }
            
            return simulatedResponses.default;
        }
    }

    function updateMessage(messageIndex, newContent) {
        // Update the message in the array
        if (messageIndex >= 0 && messageIndex < messages.length) {
            messages[messageIndex].content = newContent;
            
            // Find the correct DOM element index
            // If there's a welcome message, we need to offset by 1
            const hasWelcomeMessage = chatMessages.children.length > messages.length;
            const domIndex = hasWelcomeMessage ? messageIndex + 1 : messageIndex;
            
            // Update the corresponding DOM element
            const messageElements = chatMessages.children;
            if (messageElements[domIndex]) {
                const messageBubble = messageElements[domIndex].querySelector('div');
                messageBubble.textContent = newContent;
            }
            
            // Scroll to bottom during streaming updates
            scrollToBottom();
        }
    }

    function addProgressiveMessage(content, type) {
        // Add initial message and return its index
        addMessage(content, type);
        return messages.length - 1; // Return index of the newly added message
    }

    function appendToMessage(messageIndex, additionalContent) {
        // Append content to existing message
        if (messageIndex >= 0 && messageIndex < messages.length) {
            messages[messageIndex].content += additionalContent;
            
            // Update the corresponding DOM element
            const messageElements = chatMessages.children;
            if (messageElements[messageIndex]) {
                const messageBubble = messageElements[messageIndex].querySelector('div');
                messageBubble.textContent = messages[messageIndex].content;
            }
            
            // Scroll to bottom using auto-scroll function
            scrollToBottom();
        }
    }

    // Stop generation
    document.getElementById('stop-generation').addEventListener('click', function() {
        // Stop the current generation
        isGenerating = false;
        
        // Abort the current API request if it exists
        if (currentAbortController) {
            currentAbortController.abort();
        }
        
        updateInputState();
    });

    // Summarize conversation
    document.getElementById('summarize-conversation').addEventListener('click', async function() {
        // Build conversation context for summarization
        const conversationContext = messages.map(m => 
            `${m.type === 'human' ? 'User' : 'Assistant'}: ${m.content}`
        ).join('\n');
        
        const summaryPrompt = `Please provide a concise summary of the following conversation:\n\n${conversationContext}`;
        
        // Add a summarization message
        addMessage('Please provide a summary of our conversation.', 'human');
        
        // Mark as generating and update UI
        isGenerating = true;
        updateInputState();
        
        // Start AI response
        const aiMessageIndex = addProgressiveMessage('', 'ai');
        
        try {
            // Make API call for summarization
            const response = await sendChatMessage(summaryPrompt);
            
            // Display response progressively
            const words = response.split(' ');
            let currentText = '';
            
            for (let i = 0; i < words.length; i++) {
                // Check if generation was stopped
                if (!isGenerating) {
                    break;
                }
                
                currentText += (i > 0 ? ' ' : '') + words[i];
                updateMessage(aiMessageIndex, currentText);
                await new Promise(resolve => setTimeout(resolve, 30));
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                // Update message to show it was stopped
                updateMessage(aiMessageIndex, messages[aiMessageIndex].content + ' [Generation stopped]');
            } else {
                // Handle other errors
                updateMessage(aiMessageIndex, 'Sorry, an error occurred while generating the summary.');
            }
        }
        
        // Mark generation as complete
        isGenerating = false;
        currentAbortController = null;
        updateInputState();
    });

    // Enter key to send message
    modalInput.addEventListener('keydown', async function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            const message = modalInput.value.trim();
            if (message) {
                modalInput.value = '';
                
                
                // Re-enable auto-scroll when user sends a new message
                autoScrollEnabled = true;
                
                // Add user message
                addMessage(message, 'human');
                
                // Mark as generating and update UI
                isGenerating = true;
                updateInputState();
                
                // Start AI response
                const aiMessageIndex = addProgressiveMessage('', 'ai');
                
                try {
                    // Make API call
                    const response = await sendChatMessage(message);
                    
                    // Display response progressively
                    const words = response.split(' ');
                    let currentText = '';
                    
                    for (let i = 0; i < words.length; i++) {
                        // Check if generation was stopped
                        if (!isGenerating) {
                            break;
                        }
                        
                        currentText += (i > 0 ? ' ' : '') + words[i];
                        updateMessage(aiMessageIndex, currentText);
                        await new Promise(resolve => setTimeout(resolve, 30));
                    }
                } catch (error) {
                    if (error.name === 'AbortError') {
                        // Update message to show it was stopped
                        updateMessage(aiMessageIndex, messages[aiMessageIndex].content + ' [Generation stopped]');
                    } else {
                        // Handle other errors
                        updateMessage(aiMessageIndex, 'Sorry, an error occurred while generating the response.');
                    }
                }
                
                // Mark generation as complete
                isGenerating = false;
                currentAbortController = null;
                updateInputState();
            }
        }
    });

    // Clear conversation event listener
    document.getElementById('clear-conversation').addEventListener('click', clearConversation);
});
</script>
