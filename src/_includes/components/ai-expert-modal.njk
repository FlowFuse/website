<!-- AI Expert Assistant Modal -->
<div id="ai-expert-modal" class="fixed inset-0 bg-black/50 hidden items-center justify-center p-0 md:p-4 md:px-8 md:py-8 z-[9999]">
    <!-- Modal Content -->
    <div class="bg-white rounded-none md:rounded-lg shadow-xl w-full max-w-4xl h-full md:h-full flex flex-col relative">
        
        <!-- Header -->
        <div class="ai-chat-box"><div class="textarea-wrapper modal-header flex items-center justify-between px-4 py-3 rounded-t-none md:rounded-t-lg h-auto rounded-b-none mb-0">
            <div class="flex items-center gap-1">
                <!-- FlowFuse Logo -->
                <div class="w-24 h-6">
                    {% include "components/flowfuse-wordmark.njk" %}
                </div>
                <h2 class="text-base font-semibold text-gray-700 -mb-1">Expert Assistant</h2>
            </div>
            <button id="close-modal" class="text-gray-400 hover:text-gray-600">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                    <path d="M18 6L6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
        </div></div>

        <!-- Chat Content -->
        <div class="flex-1 p-4 overflow-y-auto">
            <!-- Info Message -->
            <div class="bg-indigo-100 rounded-lg mb-6 py-3 px-4">
                <p class="text-indigo-700 text-sm m-0">
                    Uses OpenAI GPT-4.1 Mini with access to all FlowFuse 
                    <a href="/docs" class="underline">documentation</a> 
                    and our Get Started 
                    <a href="https://www.youtube.com/watch?v=K4xw09DbSdI&list=PLpcyqc7kNgp1dCDliNM4WOPf6d42Qmjvf" class="underline">YouTube playlist</a>
                </p>
            </div>

            <!-- Chat Messages Container -->
            <div id="chat-messages" class="space-y-4">
                <!-- Messages will be added here dynamically -->
            </div>

        </div>

        <!-- Input Area -->
        <div class="p-4 bg-white rounded-b-none md:rounded-b-lg border-t border-gray-200">
            <div id="action-buttons-container" class="pb-4 flex justify-between">
                <button id="clear-conversation" class="bg-white border border-indigo-300 rounded-full text-sm py-2 px-3 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    Start over
                </button>
                <div id="right-buttons" class="flex gap-2">
                    <button id="stop-generation" class="bg-white border border-indigo-300 rounded-full text-sm flex items-center gap-2 py-2 px-3 hidden">
                        <div class="w-3 h-3 bg-gray-800 rounded-sm"></div>
                        Stop
                    </button>
                    <button id="send-message" class="bg-indigo-600 text-white border border-indigo-600 rounded-full text-sm py-2 px-3 disabled:opacity-50 disabled:cursor-not-allowed hover:bg-indigo-700 transition-colors" disabled>
                        Send
                    </button>
                </div>
            </div>
            <div class="relative">
                <textarea 
                    id="modal-input"
                    placeholder="Give more details in regards to your intended workflow to tailor it to your use case"
                    class="w-full p-4 border-2 border-gray-300 rounded-lg resize-none focus:outline-none focus:border-indigo-500 text-gray-900 h-24 text-sm disabled:cursor-not-allowed disabled:bg-gray-50 disabled:text-gray-500"
                ></textarea>
            </div>
            <div class="flex justify-between mt-2 text-xs text-gray-500">
                <span>Powered by OpenAI</span>
                <span>Rate limited. Fair use only</span>
            </div>
        </div>

    </div>
</div>

<!-- CSS for Loading Animation -->
<style>
.ai-loading-dots {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    color: theme(colors.indigo.500);
    font-style: italic;
}

.ai-loading-dots::after {
    content: '';
    display: inline-flex;
    gap: 2px;
    margin-left: 8px;
}

.ai-loading-dots::after {
    content: '●●●';
    animation: loading-dots 1.5s infinite;
    letter-spacing: 2px;
}

@keyframes loading-dots {
    0% { opacity: 0.2; }
    20% { opacity: 1; }
    40% { opacity: 0.2; }
    60% { opacity: 0.2; }
    80% { opacity: 0.2; }
    100% { opacity: 0.2; }
}

.ai-loading-dots[data-dot="1"]::after {
    animation-delay: 0s;
}

.ai-loading-dots[data-dot="2"]::after {
    animation-delay: 0.2s;
}

.ai-loading-dots[data-dot="3"]::after {
    animation-delay: 0.4s;
}

.loading-dot {
    display: inline-block;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background-color: theme(colors.indigo.500);
    animation: bounce-dot 1.4s infinite ease-in-out;
    margin: 0 1px;
}

.loading-dot:nth-child(1) { animation-delay: -0.32s; }
.loading-dot:nth-child(2) { animation-delay: -0.16s; }
.loading-dot:nth-child(3) { animation-delay: 0s; }

@keyframes bounce-dot {
    0%, 80%, 100% {
        transform: scale(0.8);
        opacity: 0.5;
    }
    40% {
        transform: scale(1);
        opacity: 1;
    }
}

/* Rich content styles - using Tailwind theme values */
.rich-content {
    max-width: 90%;
}

.rich-content h3 {
    @apply mb-2 text-lg font-semibold text-gray-900;
}

.rich-content h4 {
    @apply mt-4 mb-3 text-base font-medium text-gray-900;
}

.rich-content h5 {
    @apply mb-1 text-base font-medium text-gray-900;
}

.rich-content h6 {
    @apply mb-1 text-sm font-medium text-gray-900;
}

.rich-content p {
    @apply mt-0 mb-4 leading-relaxed text-gray-700;
}

.rich-content ol {
    @apply m-0 p-0 list-none;
}

.rich-content li {
    @apply mb-3;
}

.rich-content code {
    @apply font-mono bg-gray-100 px-1 py-0.5 rounded text-sm;
}

.rich-content a {
    text-decoration: none;
    color: inherit;
}

.rich-content a:hover {
    text-decoration: none;
}

/* Button hover effects */
.rich-content button:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}

.rich-content button {
    transition: var(--tdur, 0.15s) transform, var(--tdur, 0.15s) box-shadow;
}

/* Remove bottom margin from last element in rich content */
.rich-content > *:last-child {
    margin-bottom: 0;
}

/* Remove bottom margin from paragraphs inside resource links */
.rich-content a p {
    margin-bottom: 0;
}

/* Remove all margins from chat message paragraphs */
.rich-content > p:only-child {
    margin: 0;
}

</style>

<!-- JavaScript for Modal Functionality -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    const modal = document.getElementById('ai-expert-modal');
    const closeBtn = document.getElementById('close-modal');
    const tellMeHowBtn = document.querySelector('[onclick*="cta-ai-tell-me-how"]');
    const chatMessages = document.getElementById('chat-messages');
    const modalInput = document.getElementById('modal-input');
    
    // Message storage array
    let messages = [];
    
    // Session ID for chat isolation
    let sessionId = null;
    
    // Variables for stopping generation
    let currentAbortController = null;
    let isGenerating = false;
    
    // Transaction ID for preventing race conditions
    let lastTransactionId = null;
    
    // Auto-scroll management
    let autoScrollEnabled = true;
    const scrollThreshold = 50; // pixels from bottom to consider "at bottom"
    
    // Loading messages system
    const loadingMessages = [
        "Please wait, this can take up to 20 seconds",
        "Searching through our documentation",
        "Thinking through your question"
    ];
    let currentLoadingMessageIndex = 0;
    let loadingMessageInterval = null;

    // Centralized function to manage input state based on isGenerating
    function updateInputState() {
        const clearBtn = document.getElementById('clear-conversation');
        const stopBtn = document.getElementById('stop-generation');
        const sendBtn = document.getElementById('send-message');
        
        if (isGenerating) {
            modalInput.disabled = true;
            // Disable clear button during generation
            if (clearBtn) clearBtn.disabled = true;
            // Show stop button, hide send button
            if (stopBtn) stopBtn.classList.remove('hidden');
            if (sendBtn) sendBtn.classList.add('hidden');
        } else {
            modalInput.disabled = false;
            modalInput.focus();
            // Enable clear button only if there are messages
            const hasMessages = messages.length > 0;
            if (clearBtn) clearBtn.disabled = !hasMessages;
            // Hide stop button, show summarize button if there are messages
            if (stopBtn) stopBtn.classList.add('hidden');
            if (sendBtn) {
                // Enable/disable send button based on textarea content
                const hasContent = modalInput.value.trim().length > 0;
                sendBtn.disabled = !hasContent;
                sendBtn.classList.remove('hidden');
            }
        }
    }

    // Check if user is at bottom of scroll container
    function isAtBottom() {
        const container = chatMessages.parentElement; // Get the scrollable container
        return container.scrollHeight - container.scrollTop - container.clientHeight < scrollThreshold;
    }
    
    // Scroll to bottom if auto-scroll is enabled
    function scrollToBottom() {
        if (autoScrollEnabled) {
            const container = chatMessages.parentElement;
            container.scrollTop = container.scrollHeight;
        }
    }
    
    // Set up scroll detection on the chat container
    const chatContainer = chatMessages.parentElement;
    chatContainer.addEventListener('scroll', function() {
        // Check if user is at bottom
        if (isAtBottom()) {
            // Re-enable auto-scroll when user scrolls to bottom
            autoScrollEnabled = true;
        } else {
            // Disable auto-scroll when user scrolls up
            autoScrollEnabled = false;
        }
    });
    
    // Open modal
    if (tellMeHowBtn) {
        tellMeHowBtn.addEventListener('click', function(e) {
            e.preventDefault();
            const userText = document.querySelector('textarea[aria-label="Describe your workflow"]').value;
            const promptText = userText.trim();
            openModal(promptText);
        });
    }

    // Close modal
    closeBtn.addEventListener('click', closeModal);
    modal.addEventListener('click', function(e) {
        if (e.target === modal) closeModal();
    });

    // Handle prompt pill clicks
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('prompt-pill') && e.target.dataset.prompt) {
            e.preventDefault();
            const promptText = e.target.dataset.prompt;
            openModal(promptText);
        }
    });

    function openModal(userText) {
        // Generate new session ID for this chat session
        sessionId = crypto.randomUUID();
        
        // Reset auto-scroll to enabled when opening modal
        autoScrollEnabled = true;
        
        // Ensure input is enabled when modal opens
        isGenerating = false;
        
        // Only show welcome message if there are no messages yet AND no user text provided
        if (messages.length === 0 && !userText) {
            showWelcomeMessage();
        }
        updateInputState();
        
        // Check if View Transitions API is supported
        if (document.startViewTransition && typeof document.startViewTransition === 'function') {
            
            // Get elements for transition
            const homeTextarea = document.querySelector('textarea[aria-label="Describe your workflow"]');
            const homeTextareaWrapper = homeTextarea.closest('.textarea-wrapper');
            // Target the entire input area div that contains textarea and footer text
            const modalInputSection = modal.querySelector('.p-4.bg-white.rounded-b-none.md\\:rounded-b-lg');
            
            
            // Set transition name on home wrapper BEFORE starting transition (for "before" snapshot)
            homeTextareaWrapper.style.viewTransitionName = 'morphing-content';
            
            // Use View Transitions API for smooth morphing
            try {
                const transition = document.startViewTransition(() => {
                    
                    // Remove transition name from home wrapper
                    homeTextareaWrapper.style.viewTransitionName = '';
                    
                    // Hide the home wrapper
                    homeTextareaWrapper.style.display = 'none';
                    
                    // Move modal to document.body and show it
                    document.body.appendChild(modal);
                    modal.classList.remove('hidden');
                    modal.classList.add('flex');
                    
                    // Give the modal input section the transition name (for "after" snapshot)
                    if (modalInputSection) {
                        modalInputSection.style.viewTransitionName = 'morphing-content';
                    }
                    
                });
                
            
            transition.finished.then(() => {
                
                // Prevent body scroll
                document.body.style.overflow = 'hidden';
                
                // Clean up transition names after animation
                if (homeTextareaWrapper) {
                    homeTextareaWrapper.style.viewTransitionName = '';
                }
                if (modalInputSection) {
                    modalInputSection.style.viewTransitionName = '';
                }
                
                // Start chat if user provided text
                if (userText) {
                    startChat(userText);
                }
            }).catch(err => {
                console.error('Transition failed:', err);
            });
            } catch (error) {
                console.error('Error starting transition:', error);
                // Fallback to immediate modal show
                homeTextareaWrapper.style.display = 'none';
                document.body.appendChild(modal);
                modal.classList.remove('hidden');
                modal.classList.add('flex');
                document.body.style.overflow = 'hidden';
                if (userText) {
                    modalInput.value = userText;
                    startChat(userText);
                }
            }
        } else {
            // Fallback for browsers without View Transitions support
            const homeTextarea = document.querySelector('textarea[aria-label="Describe your workflow"]');
            const homeTextareaWrapper = homeTextarea.closest('.textarea-wrapper');
            
            
            // Hide home textarea to avoid duplication
            homeTextareaWrapper.style.display = 'none';
            
            // Show modal immediately (no animation)
            document.body.appendChild(modal);
            modal.classList.remove('hidden');
            modal.classList.add('flex');
            document.body.style.overflow = 'hidden';
            
            if (userText) {
                startChat(userText);
            }
        }
    }

    function closeModal() {
        const homeTextarea = document.querySelector('textarea[aria-label="Describe your workflow"]');
        const homeTextareaWrapper = homeTextarea ? homeTextarea.closest('.textarea-wrapper') : null;
        const modalInputSection = modal.querySelector('.p-4.bg-white.rounded-b-none.md\\:rounded-b-lg');
        
        // Check if View Transitions API is supported
        if (document.startViewTransition && typeof document.startViewTransition === 'function') {
            // Set transition name on modal input section (for "before" snapshot)
            if (modalInputSection) {
                modalInputSection.style.viewTransitionName = 'morphing-content';
            }
            
            // Use View Transitions for smooth reverse morph
            const transition = document.startViewTransition(() => {
                // Remove transition name from modal
                if (modalInputSection) {
                    modalInputSection.style.viewTransitionName = '';
                }
                
                // Hide modal
                modal.classList.add('hidden');
                modal.classList.remove('flex');
                
                // Show home wrapper with transition name (for "after" snapshot)
                if (homeTextareaWrapper) {
                    homeTextareaWrapper.style.display = '';
                    homeTextareaWrapper.style.viewTransitionName = 'morphing-content';
                }
            });
            
            transition.finished.then(() => {
                // Clean up after transition
                document.body.style.overflow = '';
                if (homeTextareaWrapper) {
                    homeTextareaWrapper.style.viewTransitionName = '';
                }
                
                // Reset modal state
                clearMessages();
                modalInput.value = '';
                sessionId = null;  // Clear session ID
                lastTransactionId = null;  // Clear transaction ID
                
                // Hide both button containers
                const stopButtonContainer = document.getElementById('stop-button-container');
                const summarizeButtonContainer = document.getElementById('summarize-button-container');
                stopButtonContainer.classList.add('hidden');
                summarizeButtonContainer.classList.add('hidden');
            });
        } else {
            // Fallback for browsers without View Transitions
            modal.classList.add('hidden');
            modal.classList.remove('flex');
            document.body.style.overflow = '';
            
            // Restore home textarea
            if (homeTextareaWrapper) {
                homeTextareaWrapper.style.display = '';
            }
            
            // Reset state
            clearMessages();
            modalInput.value = '';
            sessionId = null;  // Clear session ID
            lastTransactionId = null;  // Clear transaction ID
            
            // Hide both button containers
            const stopButtonContainer = document.getElementById('stop-button-container');
            const summarizeButtonContainer = document.getElementById('summarize-button-container');
            stopButtonContainer.classList.add('hidden');
            summarizeButtonContainer.classList.add('hidden');
        }
        
    }

    async function startChat(message) {        
        // Mark as generating and update UI
        isGenerating = true;
        updateInputState();
        
        // Add user message
        addMessage(message, 'human');
        
        // Start AI response
        const aiMessageIndex = addProgressiveMessage('', 'ai');
        
        try {
            // Make API call
            const response = await sendChatMessage(message);
            console.debug('Received response in startChat:', response);
            
            // Check if response is valid
            if (!response || !response.answer) {
                console.error('Invalid response from server:', response);
                throw new Error('Invalid response from server');
            }
            
            // Check if this response is from the most recent transaction
            if (response.transactionId !== lastTransactionId) {
                // Ignore response from cancelled/outdated request
                return;
            }
            
            // Handle multi-message vs single message responses
            if (response.isMultiMessage && Array.isArray(response.answer)) {
                // Add each message from the array, keeping the loading message until the end
                response.answer.forEach(messageObj => {
                    addAIMessageFromObject(messageObj);
                });
                
                // Now remove the initial loading message
                messages.splice(aiMessageIndex, 1); // Remove from messages array
                const aiMessageElements = chatMessages.children;
                if (aiMessageElements[aiMessageIndex]) {
                    chatMessages.removeChild(aiMessageElements[aiMessageIndex]);
                }
            } else {
                // Fallback for old single message format - treat as single chat message
                const messageText = typeof response.answer === 'string' ? response.answer : response.answer[0]?.content || 'No response';
                const words = messageText.split(' ');
                let currentText = '';
                
                for (let i = 0; i < words.length; i++) {
                    // Check if generation was stopped or transaction changed
                    if (!isGenerating || response.transactionId !== lastTransactionId) {
                        break;
                    }
                    
                    currentText += (i > 0 ? ' ' : '') + words[i];
                    updateMessage(aiMessageIndex, currentText);
                    
                    // Small delay between words for streaming effect
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                // Update message to show it was stopped
                updateMessage(aiMessageIndex, messages[aiMessageIndex].content + ' [Generation stopped]');
            } else {
                // Handle other errors
                updateMessage(aiMessageIndex, 'Sorry, an error occurred while generating the response.');
            }
        }
        
        // Mark generation as complete
        isGenerating = false;
        currentAbortController = null;
        updateInputState();
        
        // Button visibility is now handled by updateInputState()
    }

    function addMessage(content, type) {
        // Add to messages array
        const message = { content, type };
        messages.push(message);
        
        // Create DOM element
        const messageDiv = document.createElement('div');
        messageDiv.className = `flex ${type === 'human' ? 'justify-end' : 'justify-start'} mb-4`;
        
        const messageBubble = document.createElement('div');
        messageBubble.className = `max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${
            type === 'human' 
                ? 'bg-indigo-600 text-white rounded-br-sm' 
                : 'bg-gray-100 text-gray-800 rounded-bl-sm'
        }`;
        
        // If it's an AI message with empty content, show loading animation
        if (type === 'ai' && content === '') {
            messageBubble.innerHTML = `
                <div class="ai-loading-message">
                    <span class="loading-text hidden"></span>
                    <div class="inline-flex">
                        <span class="loading-dot"></span>
                        <span class="loading-dot"></span>
                        <span class="loading-dot"></span>
                    </div>
                </div>
            `;
            messageBubble.classList.add('ai-loading');
            
            // Start loading sequence: dots first, then messages
            startLoadingSequence(messageBubble);
        } else {
            messageBubble.textContent = content;
        }
        
        messageDiv.appendChild(messageBubble);
        chatMessages.appendChild(messageDiv);
        
        // Scroll to bottom using auto-scroll function
        scrollToBottom();
    }

    function renderMessages() {
        // Clear existing messages in DOM
        chatMessages.innerHTML = '';
        
        // Rebuild from messages array
        messages.forEach(message => {
            const messageDiv = document.createElement('div');
            messageDiv.className = `flex ${message.type === 'human' ? 'justify-end' : 'justify-start'} mb-4`;
            
            const messageBubble = document.createElement('div');
            messageBubble.className = `max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${
                message.type === 'human' 
                    ? 'bg-indigo-600 text-white rounded-br-sm' 
                    : 'bg-gray-100 text-gray-800 rounded-bl-sm'
            }`;
            
            if (message.isHTML) {
                messageBubble.innerHTML = message.content;
                messageBubble.classList.add('rich-content');
            } else {
                messageBubble.textContent = message.content;
            }
            
            messageDiv.appendChild(messageBubble);
            chatMessages.appendChild(messageDiv);
        });
        
        // Scroll to bottom using auto-scroll function
        scrollToBottom();
    }

    function clearMessages() {
        // Clear messages array
        messages = [];
        
        // Clear DOM
        chatMessages.innerHTML = '';
    }

    async function showWelcomeMessage() {
        // Add welcome message container (this doesn't count as a real conversation message)
        const messageDiv = document.createElement('div');
        messageDiv.className = 'flex justify-start mb-4';
        
        const messageBubble = document.createElement('div');
        messageBubble.className = 'max-w-xs lg:max-w-md px-4 py-2 rounded-lg bg-gray-100 text-gray-800 rounded-bl-sm';
        messageBubble.textContent = '';
        
        messageDiv.appendChild(messageBubble);
        chatMessages.appendChild(messageDiv);
        scrollToBottom();
        
        // Animate the typing of the welcome message
        const welcomeText = 'Hello! I am here to help you get started with FlowFuse and Node-RED. Please tell me what you are hoping to achieve.';
        const words = welcomeText.split(' ');
        let currentText = '';
        
        for (let i = 0; i < words.length; i++) {
            currentText += (i > 0 ? ' ' : '') + words[i];
            messageBubble.textContent = currentText;
            scrollToBottom();
            
            // Small delay between words for typing effect
            await new Promise(resolve => setTimeout(resolve, 50));
        }
    }

    async function clearConversation() {
        // Stop any ongoing generation
        if (currentAbortController) {
            currentAbortController.abort();
        }
        isGenerating = false;
        
        // Clear transaction ID to ignore any subsequent responses
        lastTransactionId = null;
        
        // Stop loading message rotation
        stopLoadingMessageRotation();
        
        // Clear all messages
        clearMessages();
        
        // Reset session ID for fresh conversation
        sessionId = crypto.randomUUID();
        
        // Reset auto-scroll
        autoScrollEnabled = true;
        
        // Show welcome message with typing animation
        await showWelcomeMessage();
        
        // Hide right buttons
        const stopBtn = document.getElementById('stop-generation');
        const sendBtn = document.getElementById('send-message');
        if (stopBtn) stopBtn.classList.add('hidden');
        if (summarizeBtn) summarizeBtn.classList.add('hidden');
        
        // Update input state (clear button will be disabled since messages array is empty)
        updateInputState();
    }

    async function sendChatMessage(query) {
        // Generate unique transaction ID for this request
        const transactionId = crypto.randomUUID();
        lastTransactionId = transactionId;
        
        try {
            // Create abort controller for this request
            currentAbortController = new AbortController();
            
            // Note: This API may only work in production (flowfuse.com domain)
            // For local development, we'll get simulated responses
            const response = await fetch('https://flowfuse-chatbot.flowfuse.dev/v2/expert', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Origin': window.location.origin,
                    'X-Chat-Session-ID': sessionId,
                    'X-Chat-Transaction-ID': transactionId
                },
                body: JSON.stringify({ query }),
                signal: currentAbortController.signal
            });
            
            if (!response.ok) {
                // Treat HTTP errors as API unavailable - fall through to simulation
                throw new Error(`API unavailable: ${response.status}`);
            }
            
            const data = await response.json();
            
            // Extract transaction ID from response header (if available)
            const responseTransactionId = response.headers.get('X-Chat-Transaction-ID') || transactionId;
            
            return {
                answer: data.answer,
                transactionId: responseTransactionId,
                isMultiMessage: Array.isArray(data.answer)
            };
        } catch (error) {
            // Handle abort error (user clicked stop)
            if (error.name === 'AbortError') {
                throw error; // Re-throw abort errors to be handled by caller
            }
            
            console.warn('Chat API not available (likely due to CORS in development):', error);
            console.debug('Falling back to simulated response');
            
            // Fallback to simulated response for local development
            const simulatedResponses = {
                default: "This is a test response as the API is not available right now",
                summary: "We discussed FlowFuse implementation strategies and Node-RED workflow development."
            };
            
            // Check if query contains "rich" to test rich response format
            if (query.toLowerCase().includes('rich') || query.toLowerCase().includes('test')) {
                const simulatedMessagesArray = [
                    {
                        kind: "guide",
                        title: "Convert MQTT raw values to voltage and save in FlowFuse Tables",
                        summary: "This guide explains how to convert raw MQTT values (0-4096) to voltage values (0-12V) and save them in FlowFuse Tables with an ID derived from the MQTT topic using Node-RED in FlowFuse.",
                        steps: [
                            {
                                title: "Subscribe to MQTT topic",
                                detail: "Use the MQTT input node in Node-RED to subscribe to the relevant MQTT topic that provides raw values."
                            },
                            {
                                title: "Extract ID from MQTT topic",
                                detail: "Use a Function node to parse the MQTT topic string and compute an ID. For example, extract a unique part of the topic to use as the ID."
                            },
                            {
                                title: "Convert raw value to voltage",
                                detail: "In the same or a subsequent Function node, convert the raw value (0-4096) to voltage (0-12V) using the formula: voltage = (raw_value / 4096) * 12."
                            },
                            {
                                title: "Save data in FlowFuse Tables",
                                detail: "Use the FlowFuse Tables node to insert the data object into a table. Configure the node with the appropriate table name and ensure the ID is used as a key."
                            }
                        ],
                        resources: [
                            {
                                title: "Using MQTT with Node-RED",
                                url: "https://flowfuse.com/blog/2024/06/how-to-use-mqtt-in-node-red/",
                                type: "docs"
                            },
                            {
                                title: "FlowFuse Tables for Industrial IoT",
                                url: "https://flowfuse.com/blog/2025/08/time-series-dashboard-flowfuse-postgresql/",
                                type: "blog"
                            },
                            {
                                title: "Latest Features Changelog",
                                url: "https://flowfuse.com/changelog/",
                                type: "changelog"
                            }
                        ],
                        nodePackages: [
                            {
                                name: "@flowfuse/node-red-dashboard"
                            },
                            {
                                name: "node-red-contrib-mqtt-broker"
                            }
                        ]
                    },
                    {
                        kind: "chat",
                        title: "Additional Information",
                        content: "I hope this guide helps you get started! Let me know if you have any questions about implementing this workflow or need clarification on any of the steps."
                    }
                ];
                
                const simulatedResult = {
                    answer: simulatedMessagesArray,
                    transactionId: transactionId,
                    isMultiMessage: true
                };
                console.debug('Returning simulated multi-message response:', simulatedResult);
                return simulatedResult;
            }
            
            // Check if this is a summary request
            const simulatedAnswer = query.includes('summary') ? simulatedResponses.summary : simulatedResponses.default;
            
            const simulatedResult = {
                answer: [{
                    kind: "chat",
                    content: simulatedAnswer
                }],
                transactionId: transactionId,
                isMultiMessage: true
            };
            console.debug('Returning simulated response:', simulatedResult);
            return simulatedResult;
        }
    }

    function updateMessage(messageIndex, newContent) {
        // Update the message in the array
        if (messageIndex >= 0 && messageIndex < messages.length) {
            messages[messageIndex].content = newContent;
            
            // Find the correct DOM element index
            // If there's a welcome message, we need to offset by 1
            const hasWelcomeMessage = chatMessages.children.length > messages.length;
            const domIndex = hasWelcomeMessage ? messageIndex + 1 : messageIndex;
            
            // Update the corresponding DOM element
            const messageElements = chatMessages.children;
            if (messageElements[domIndex]) {
                const messageBubble = messageElements[domIndex].querySelector('div');
                messageBubble.textContent = newContent;
            }
            
            // Scroll to bottom during streaming updates
            scrollToBottom();
        }
    }

    function updateMessageWithHTML(messageIndex, htmlContent) {
        // Update the message in the array
        if (messageIndex >= 0 && messageIndex < messages.length) {
            messages[messageIndex].content = htmlContent;
            messages[messageIndex].isHTML = true;
            
            // Find the correct DOM element index
            // If there's a welcome message, we need to offset by 1
            const hasWelcomeMessage = chatMessages.children.length > messages.length;
            const domIndex = hasWelcomeMessage ? messageIndex + 1 : messageIndex;
            
            // Update the corresponding DOM element
            const messageElements = chatMessages.children;
            if (messageElements[domIndex]) {
                const messageBubble = messageElements[domIndex].querySelector('div');
                
                // Stop loading animation first
                if (messageBubble.classList.contains('ai-loading')) {
                    stopLoadingMessageRotation();
                    messageBubble.classList.remove('ai-loading');
                }
                
                // Set HTML content
                messageBubble.innerHTML = htmlContent;
                
                // Update styles for rich content
                messageBubble.classList.add('rich-content');
            }
            
            // Scroll to bottom
            scrollToBottom();
        }
    }

    function addProgressiveMessage(content, type) {
        // Add initial message and return its index
        addMessage(content, type);
        return messages.length - 1; // Return index of the newly added message
    }

    function addAIMessageFromObject(messageObj) {
        // Add to messages array
        const message = { content: '', type: 'ai', isHTML: true };
        messages.push(message);
        
        // Create DOM element
        const messageDiv = document.createElement('div');
        messageDiv.className = 'flex justify-start mb-4';
        
        const messageBubble = document.createElement('div');
        let paddingClass = messageObj.kind === 'guide' ? 'py-4' : 'py-2';
        messageBubble.className = `max-w-xs lg:max-w-md px-4 ${paddingClass} rounded-lg bg-gray-100 text-gray-800 rounded-bl-sm rich-content`;
        
        // Render content based on message kind
        let htmlContent = '';
        if (messageObj.kind === 'guide') {
            htmlContent = renderRichContent(messageObj);
        } else if (messageObj.kind === 'chat') {
            htmlContent = renderChatContent(messageObj);
        }
        
        // Update message content and DOM
        message.content = htmlContent;
        messageBubble.innerHTML = htmlContent;
        
        messageDiv.appendChild(messageBubble);
        chatMessages.appendChild(messageDiv);
        
        // Scroll to bottom
        scrollToBottom();
        
        return messages.length - 1; // Return index of the newly added message
    }

    function appendToMessage(messageIndex, additionalContent) {
        // Append content to existing message
        if (messageIndex >= 0 && messageIndex < messages.length) {
            messages[messageIndex].content += additionalContent;
            
            // Update the corresponding DOM element
            const messageElements = chatMessages.children;
            if (messageElements[messageIndex]) {
                const messageBubble = messageElements[messageIndex].querySelector('div');
                
                // If this is the first real content being added to an AI message, stop loading animation
                if (messageBubble.classList.contains('ai-loading') && additionalContent.trim() !== '') {
                    stopLoadingMessageRotation();
                    messageBubble.classList.remove('ai-loading');
                    messageBubble.innerHTML = ''; // Clear loading content
                }
                
                messageBubble.textContent = messages[messageIndex].content;
            }
            
            // Scroll to bottom using auto-scroll function
            scrollToBottom();
        }
    }
    
    function startLoadingSequence(messageBubble) {
        // Clear any existing interval
        if (loadingMessageInterval) {
            clearInterval(loadingMessageInterval);
        }
        
        // Show just dots for the first 5 seconds
        setTimeout(() => {
            // After 5 seconds, start showing messages with dots
            const loadingTextElement = messageBubble.querySelector('.loading-text');
            if (loadingTextElement && messageBubble.classList.contains('ai-loading')) {
                // Show the first message
                currentLoadingMessageIndex = 0;
                loadingTextElement.textContent = loadingMessages[currentLoadingMessageIndex];
                loadingTextElement.classList.remove('hidden');
                loadingTextElement.classList.add('inline', 'mr-2');
                
                // Start rotating messages every 5 seconds
                loadingMessageInterval = setInterval(() => {
                    if (messageBubble.classList.contains('ai-loading')) {
                        currentLoadingMessageIndex = (currentLoadingMessageIndex + 1) % loadingMessages.length;
                        const textElement = messageBubble.querySelector('.loading-text');
                        if (textElement) {
                            textElement.textContent = loadingMessages[currentLoadingMessageIndex];
                        }
                    }
                }, 5000);
            }
        }, 5000);
    }
    
    function stopLoadingMessageRotation() {
        if (loadingMessageInterval) {
            clearInterval(loadingMessageInterval);
            loadingMessageInterval = null;
        }
    }

    function renderChatContent(chatMessage) {
        let html = '';
        
        // Content (no title for chat messages)
        if (chatMessage.content) {
            html += `<p class="text-gray-700">${chatMessage.content}</p>`;
        }
        
        return html;
    }

    function addUTMParameters(url) {
        try {
            const urlObj = new URL(url);
            urlObj.searchParams.set('utm_campaign', '215266513-FlowFuse Expert');
            return urlObj.toString();
        } catch (e) {
            // If URL parsing fails, return original URL
            return url;
        }
    }

    function renderRichContent(richAnswer) {
        let html = '';

        // Setup Guide label for guide messages
        html += `<div class="bg-indigo-100 text-indigo-700 text-sm px-3 py-2 rounded-full inline-block mb-3">Setup Guide</div>`;

        // Title
        if (richAnswer.title) {
            html += `<h3 class="text-lg font-semibold text-gray-900 mb-2">${richAnswer.title}</h3>`;
        }

        // Summary
        if (richAnswer.summary) {
            html += `<p class="text-gray-700 mb-4">${richAnswer.summary}</p>`;
        }

        // Steps
        if (richAnswer.steps && richAnswer.steps.length > 0) {
            html += '<div class="mb-4">';
            html += '<h4 class="text-base font-medium text-gray-900 mb-3">Steps:</h4>';
            html += '<ol class="space-y-3">';

            richAnswer.steps.forEach((step, index) => {
                html += `
                <li class="flex">
                    <span class="flex-shrink-0 w-6 h-6 bg-indigo-600 text-white rounded-full text-sm flex items-center justify-center mr-3 mt-0.5">${index + 1}</span>
                    <div>
                        <h5 class="font-medium text-gray-900">${step.title}</h5>
                        <p class="text-gray-600 text-sm mt-1">${step.detail}</p>
                    </div>
                </li>`;
            });

            html += '</ol>';
            html += '</div>';
        }

        // Node Packages
        if (richAnswer.nodePackages && richAnswer.nodePackages.length > 0) {
            html += '<div class="mb-4">';
            html += '<h4 class="text-base font-medium text-gray-900 mb-3">Required Node Packages</h4>';
            html += '<div class="grid grid-cols-1 md:grid-cols-2 gap-2">';

            richAnswer.nodePackages.forEach(pkg => {
                const nodeRedUrl = `https://flows.nodered.org/node/${pkg.name}`;
                const nodeRedUrlWithUTM = addUTMParameters(nodeRedUrl);
                const faviconUrl = `https://www.google.com/s2/favicons?domain=flows.nodered.org`;

                html += `
                <a href="${nodeRedUrlWithUTM}" target="_blank" rel="noopener noreferrer"
                   class="flex items-center gap-2 p-3 bg-white border border-gray-200 rounded-lg hover:border-indigo-300 hover:bg-gray-50 transition-colors h-16">
                    <img src="${faviconUrl}" class="w-4 h-4 flex-shrink-0" alt="">
                    <div class="flex-1 min-w-0">
                        <h6 class="font-mono text-gray-900 text-sm truncate">${pkg.name}</h6>
                        <p class="text-xs text-gray-500 mt-1 mb-0 truncate">${nodeRedUrl}</p>
                    </div>
                </a>`;
            });

            html += '</div>';
            html += '</div>';
        }

        // Resources
        if (richAnswer.resources && richAnswer.resources.length > 0) {
            html += '<div>';
            html += '<h4 class="text-base font-medium text-gray-900 mb-3">Related Resources</h4>';
            html += '<div class="grid grid-cols-1 md:grid-cols-2 gap-2">';

            richAnswer.resources.forEach(resource => {
                const faviconUrl = `https://www.google.com/s2/favicons?domain=${new URL(resource.url).hostname}`;
                const resourceUrlWithUTM = addUTMParameters(resource.url);

                html += `
                <a href="${resourceUrlWithUTM}" target="_blank" rel="noopener noreferrer"
                   class="block p-3 bg-white border border-gray-200 rounded-lg hover:border-indigo-300 hover:bg-gray-50 transition-colors">
                    <div class="flex items-start gap-2">
                        <img src="${faviconUrl}" class="w-4 h-4 flex-shrink-0 mt-0.5" alt="">
                        <div class="flex-1 min-w-0">
                            <h6 class="font-medium text-gray-900 text-sm truncate">${resource.title}</h6>
                            <p class="text-xs text-gray-500 mt-1 truncate">${resource.url}</p>
                        </div>
                    </div>
                </a>`;
            });

            html += '</div>';
            html += '</div>';
        }

        return html;
    }
    

    // Stop generation
    document.getElementById('stop-generation').addEventListener('click', function() {
        // Stop the current generation
        isGenerating = false;
        
        // Clear transaction ID to ignore any subsequent responses
        lastTransactionId = null;
        
        // Stop loading message rotation
        stopLoadingMessageRotation();
        
        // Abort the current API request if it exists
        if (currentAbortController) {
            currentAbortController.abort();
        }
        
        updateInputState();
    });

    // Send message
    document.getElementById('send-message').addEventListener('click', async function() {
        const message = modalInput.value.trim();
        if (!message) return; // Don't send empty messages
        
        // Clear the input
        modalInput.value = '';
        
        // Add user message
        addMessage(message, 'human');
        
        // Mark as generating and update UI
        isGenerating = true;
        updateInputState();
        
        // Start AI response
        const aiMessageIndex = addProgressiveMessage('', 'ai');
        
        try {
            // Make API call
            const response = await sendChatMessage(message);
            
            // Check if response is valid
            if (!response || !response.answer) {
                throw new Error('Invalid response from server');
            }
            
            // Check if this response is from the most recent transaction
            if (response.transactionId !== lastTransactionId) {
                // Ignore response from cancelled/outdated request
                return;
            }
            
            // Handle multi-message vs single message responses
            if (response.isMultiMessage && Array.isArray(response.answer)) {
                // Add each message from the array, keeping the loading message until the end
                response.answer.forEach(messageObj => {
                    addAIMessageFromObject(messageObj);
                });
                
                // Now remove the initial loading message
                messages.splice(aiMessageIndex, 1); // Remove from messages array
                const aiMessageElements = chatMessages.children;
                if (aiMessageElements[aiMessageIndex]) {
                    chatMessages.removeChild(aiMessageElements[aiMessageIndex]);
                }
            } else {
                // Fallback for old single message format - treat as single chat message
                const messageText = typeof response.answer === 'string' ? response.answer : response.answer[0]?.content || 'No response';
                const words = messageText.split(' ');
                let currentText = '';
                
                for (let i = 0; i < words.length; i++) {
                    // Check if generation was stopped or transaction changed
                    if (!isGenerating || response.transactionId !== lastTransactionId) {
                        break;
                    }
                    
                    currentText += (i > 0 ? ' ' : '') + words[i];
                    updateMessage(aiMessageIndex, currentText);
                    await new Promise(resolve => setTimeout(resolve, 30));
                }
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                // Update message to show it was stopped
                updateMessage(aiMessageIndex, messages[aiMessageIndex].content + ' [Generation stopped]');
            } else {
                // Handle other errors
                updateMessage(aiMessageIndex, 'Sorry, an error occurred while generating the response.');
            }
        }
        
        // Mark generation as complete
        isGenerating = false;
        currentAbortController = null;
        updateInputState();
    });

    // Update send button when typing
    modalInput.addEventListener('input', function() {
        updateInputState();
    });

    // Enter key to send message
    modalInput.addEventListener('keydown', async function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            const message = modalInput.value.trim();
            if (message) {
                modalInput.value = '';
                
                
                // Re-enable auto-scroll when user sends a new message
                autoScrollEnabled = true;
                
                // Add user message
                addMessage(message, 'human');
                
                // Mark as generating and update UI
                isGenerating = true;
                updateInputState();
                
                // Start AI response
                const aiMessageIndex = addProgressiveMessage('', 'ai');
                
                try {
                    // Make API call
                    const response = await sendChatMessage(message);
                    
                    // Check if response is valid
                    if (!response || !response.answer) {
                        throw new Error('Invalid response from server');
                    }
                    
                    // Check if this response is from the most recent transaction
                    if (response.transactionId !== lastTransactionId) {
                        // Ignore response from cancelled/outdated request
                        return;
                    }
                    
                    // Handle multi-message vs single message responses
                    if (response.isMultiMessage && Array.isArray(response.answer)) {
                        // Remove the initial empty AI message since we'll add multiple messages
                        messages.pop();
                        const aiMessageElements = chatMessages.children;
                        const lastElement = aiMessageElements[aiMessageElements.length - 1];
                        if (lastElement) {
                            chatMessages.removeChild(lastElement);
                        }
                        
                        // Add each message from the array
                        response.answer.forEach(messageObj => {
                            addAIMessageFromObject(messageObj);
                        });
                    } else {
                        // Fallback for old single message format - treat as single chat message
                        const messageText = typeof response.answer === 'string' ? response.answer : response.answer[0]?.content || 'No response';
                        const words = messageText.split(' ');
                        let currentText = '';
                        
                        for (let i = 0; i < words.length; i++) {
                            // Check if generation was stopped or transaction changed
                            if (!isGenerating || response.transactionId !== lastTransactionId) {
                                break;
                            }
                            
                            currentText += (i > 0 ? ' ' : '') + words[i];
                            updateMessage(aiMessageIndex, currentText);
                            await new Promise(resolve => setTimeout(resolve, 30));
                        }
                    }
                } catch (error) {
                    if (error.name === 'AbortError') {
                        // Update message to show it was stopped
                        updateMessage(aiMessageIndex, messages[aiMessageIndex].content + ' [Generation stopped]');
                    } else {
                        // Handle other errors
                        updateMessage(aiMessageIndex, 'Sorry, an error occurred while generating the response.');
                    }
                }
                
                // Mark generation as complete
                isGenerating = false;
                currentAbortController = null;
                updateInputState();
            }
        }
    });

    // Clear conversation event listener
    document.getElementById('clear-conversation').addEventListener('click', clearConversation);
});
</script>
